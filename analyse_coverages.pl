#!/usr/bin/perl

#---------------------------------------------------------------------
#   Last modified: 28 january 2025
#
#   Calculation of coverages of primer/genome alignments
#
#   primer --> code for the primer set without the extension ".fasta"
#   genomes --> folder containing genome files
#   tech --> technique analysed, e.g. pcr, lamp
#   temp --> range of temperature in celsius
#
#   perl analyse_coverages.pl primer genomes tech temp
#
#---------------------------------------------------------------------

use strict;
use List::Util 'first';
use List::MoreUtils 'pairwise';
use Storable qw(retrieve nstore);

my @ignore_ids;

my $primer=$ARGV[0];

#creating files for results
my $primer_tm_file="$primer-primer.dat";

my $match_tm_file="$primer-res-can.dat";
my $mm_tm_file="$primer-res-mm.dat";

my $genome=$ARGV[1];
my $gdir="$genome";

my $pcr=$ARGV[2];

#creating files for results
my $output_file="$primer-$genome-analysis.txt";
open(OUT,">$output_file");

my $summary_file="$primer-$genome-summary.txt";
open(SUM,">$summary_file");

my $not_aligned_file="$primer-$genome-not-aligned.txt";
open(NOT,">$not_aligned_file");

print OUT "primer=$primer genomes=$genome\n";

my @genome_files=glob("$genome/*.fasta");

#filter files by size so that we only get complete genomes
my $size_limit=25000;

print OUT "total genome files=",scalar(@genome_files);
@genome_files=grep {-s $_ > $size_limit}  @genome_files;
print OUT " files larger than $size_limit=",scalar(@genome_files),"\n";

my @genomes=grep(s/..\/$genome\/(.+).fasta/$1/,@genome_files);
my $number_of_genomes=scalar(@genomes);

#$genome-table.hash now stores the hash into a file
#so that we can compare later how each genome is covered
my $genome_table_hash_file="$genome-table.hash";
my %genomes_status;
my $gs_ref;
if (-e $genome_table_hash_file)
  {
  $gs_ref = retrieve($genome_table_hash_file);
  %genomes_status = %$gs_ref;
  }

foreach my $g (@genomes)
  {
  delete($genomes_status{$g}{$pcr}{$primer}) if (exists $genomes_status{$g}{$pcr}{$primer}); #removing the info we already had for this primer
  $genomes_status{$g}{$pcr}{$primer}{'n'}++ ; #to guarantee that $genomes_status{$g}{$pcr}{$primer} itself is a hash
  }

my $delta_tm_limit=$ARGV[3];

my $lowest_tm_limit=40;

my %h;
my $lowest_can_tm=100;
my $lowest_can_tm_id='';
my $highest_can_tm=-100;
my $highest_can_tm_id='';

my %ignored_ids;

sub extract
  {
  my $l=shift;
  my @f=split(/\s+/,$l);
  my $seq=$f[0];

  my $id=$f[18];
  $id =~ s/#//;

  my $genome='';
  my $pos='';
  if ($id =~ /^(.+)@(.+)@(.+)$/)
    {
    $id=$1;
    $genome=$2;
    $pos=$3;
    }

  if ($id ~~ @ignore_ids)
    {
    $ignored_ids{$id}++;
    return;
    }


  my $mm='';
  if (exists $f[19])
    {
    $mm=$f[19];
    $mm =~ s/mm=(.*)/$1/;
    }
  
  my $dr='';
  if (exists $f[22])
    {
    $dr=$f[22];
    $dr =~ s/dir=(.*)/$1/;
    }

  my @algn;

  #algn=X||XXX||X|||X|X||X|
  if ($l =~ /algn=(.*?)\s/)
    {
    my $algn=$1;
    $algn =~ tr/X|/10/;
    @algn=split('',$algn);
    @algn = reverse(@algn); #since primers in the file are given 3'->5'
    }
  
  my $tm=$f[6];
  next if ($tm < $lowest_tm_limit); #we are not interested in alignments with too low Tm

  if ($genome ne '')
    {
    #https://stackoverflow.com/questions/2925604/how-do-i-search-a-perl-array-for-a-matching-string#2925834
    next if (not first { /$genome/ } @genomes);

    if (exists $h{$id}{'match'}{$genome}{$pos}{$dr})
      {
      print "entry $genome $pos $dr already exists\n";
      exit;
      }
    $h{$id}{'match'}{$genome}{$pos}{$dr}{'seq'}=$seq;
    $h{$id}{'match'}{$genome}{$pos}{$dr}{'tm'}=$tm;
    $h{$id}{'match'}{$genome}{$pos}{$dr}{'mm'}=$mm;
    @{$h{$id}{'match'}{$genome}{$pos}{$dr}{'algn'}}=@algn;

    if (exists $h{$id}{'can'}{'tm'})
      {
      $h{$id}{'match'}{$genome}{$pos}{$dr}{'delta_tm'}=$h{$id}{'can'}{'tm'}-$tm;
      }
    else
      {
      $h{$id}{'match'}{$genome}{$pos}{$dr}{'delta_tm'}="no tm";
      }
    }
  else
    {
    @{$h{$id}{'absent'}}=() if (not exists $h{$id}{'absent'}); #this is only to guarantee that $h{$id}{'absent'} exists, even if empty
    $h{$id}{'can'}{'seq'}=$seq;
    $h{$id}{'can'}{'tm'}=$tm;
    if ($tm < $lowest_can_tm)
      {
      $lowest_can_tm=$tm;
      $lowest_can_tm_id=$id;
      }
    if ($tm > $highest_can_tm)
      {
      $highest_can_tm=$tm;
      $highest_can_tm_id=$id;
      }
    }
  }

sub read_file
  {
  my $file=shift;
  open(PTM,$file) or die("could not open $file");
  my $line=<PTM>;#skip

  while($line=<PTM>)
    {
    my @f=split(/\s+/,$line);
    if (scalar(@f) > 10)
      {
      extract($line,\%h);
      }
    }
  }

#reading and interpreting files
read_file($primer_tm_file); #tm_files generated by primer-tm.pl used as reference

print OUT "Lowest probe $lowest_can_tm_id Tm=$lowest_can_tm\n";

read_file($match_tm_file); #perfectly matched files
read_file($mm_tm_file);

#checking which genomes were not found
foreach my $id (sort keys %h)
  {
  foreach my $g (@genomes)
    {
    push(@{$h{$id}{'absent'}}, $g) if (not exists $h{$id}{'match'}{$g});
    }
  }

#after reading and identifying
#collecting the results in several lists
my @lp_match;
my @lp_glist;
my @lp_glist_miss;
my @delta_match;
my @delta_miss;
my @delta_glist;
my @delta_glist_miss;
my %align_mm;

foreach my $id (sort keys %h)
  {
  @delta_match=(); @delta_glist=(); @delta_glist_miss=(); @lp_match=(); @lp_glist=(); @lp_glist_miss=();
  print OUT "$id Tm=$h{$id}{'can'}{'tm'}\n";


  my @genlist=sort keys %{$h{$id}{'match'}};
  foreach my $g (@genlist)
    {
#    print "$g $h{$id}{'match'}{$g}{'seq'} $h{$id}{'match'}{$g}{'tm'} $h{$id}{'match'}{$g}{'mm'}\n";

    #in principle, only there should be only p and one dr (r or D), however for partial match there could be both
    #then we need to establish first, which one is the best (highest Tm) 
    my $best_tm=-100;
    my $best_p='';
    my $best_dr='';
    foreach my $p (sort keys %{$h{$id}{'match'}{$g}} )
      {
      foreach my $dr (sort keys %{$h{$id}{'match'}{$g}{$p}})
        {
        @{$align_mm{$id}} = (0) x length($h{$id}{'match'}{$g}{$p}{$dr}{'seq'}) if (not exists $align_mm{$id});
        my $this_tm=$h{$id}{'match'}{$g}{$p}{$dr}{'tm'};
        if ($this_tm > $best_tm)
          {
          $best_tm = $this_tm;
          $best_p  = $p;
          $best_dr = $dr;
          }
        #@{$h{$id}{'match'}{$genome}{$pos}{$dr}{'algn'}}
        @{$align_mm{$id}} = pairwise {$a+$b} @{$align_mm{$id}}, @{$h{$id}{'match'}{$g}{$p}{$dr}{'algn'}};
        }
     #$h{$id}{'match'}{$genome}{$pos}{$dr}{'algn'}
     }

     if ($best_dr and $best_p) #should $best_dr='' we skip this
        {
        my $delta_tm=$h{$id}{'match'}{$g}{$best_p}{$best_dr}{'delta_tm'};
        my $mm=$h{$id}{'match'}{$g}{$best_p}{$best_dr}{'mm'};
        my $tm=$h{$id}{'match'}{$g}{$best_p}{$best_dr}{'tm'};
        my $delta_probe=$lowest_can_tm - $tm;
        if ($delta_tm < $delta_tm_limit)
          {
          $delta_match[$mm]++;
          push(@{$delta_glist[$mm]},"$g($tm $delta_tm $best_dr $mm)") if ($mm > 0);
          push(@{$genomes_status{$g}{$pcr}{$primer}{'delta Tm'}},$id);

          }
        else { push(@delta_glist_miss,"$g($tm $delta_tm $best_dr $mm)"); }
        if ($delta_probe <= 0)
          {
          $lp_match[$mm]++;
          push(@{$lp_glist[$mm]},"$g($tm $delta_probe $best_dr $mm)") if ($mm > 0);
          push(@{$genomes_status{$g}{$pcr}{$primer}{'delta probe'}},$id);
          }
        else { push(@lp_glist_miss,"$g($tm $delta_tm $best_dr $mm)"); }
        }
    }


  my $aligned=scalar(keys %{$h{$id}{'match'}});
  if ($aligned <= 5) { print OUT join(',',keys %{$h{$id}{'match'}}),"\n"; }

  my $absent=scalar(@{$h{$id}{'absent'}});
  print OUT "genomes=$number_of_genomes aligned=$aligned no-alignment=$absent\n";
  if ($absent > 0 and $absent < 10) { print OUT "no-alignment= ",join(',',@{$h{$id}{'absent'}}),"\n"; }
  if ($absent > 0)  { print NOT "$id (no-alignment): ",join(',',@{$h{$id}{'absent'}}),"\n"; }

  if (scalar(@delta_glist_miss) > 0) { print NOT "$id (delta Tm miss): ",join(',',@delta_glist_miss),"\n"; }
  if (scalar(@lp_glist_miss) > 0) { print NOT "$id (delta probe miss): ",join(',',@lp_glist_miss),"\n"; }

  $h{$id}{'aligned'}=$aligned;

  my $pm_match=0;
  
  for(my $i=0)
    {
    if ($delta_match[$i])
      {
      print OUT "(delta match) mm=$i genomes=$delta_match[$i] ";
      print OUT join(',',@{$delta_glist[$i]}) if(exists $delta_glist[$i]);
      print OUT "\n" ;
      $pm_match=$delta_match[$i];
      }
    }
    
    my $coverage=$pm_match/$number_of_genomes*100;
    $h{$id}{'delta match'}{'coverage'}=$coverage;
    $h{$id}{'delta match'}{'covered'}=$pm_match;
    print OUT "(delta match) perfect alignment ($pm_match) =",$pm_match," coverage=$coverage%\n";
    
  for(my $i=1; $i < scalar(@delta_match);$i++)
    {
    if ($delta_match[$i])
      {
      print OUT "(delta Tm) mm=$i genomes=$delta_match[$i] ";
      print OUT join(',',@{$delta_glist[$i]}) if(exists $delta_glist[$i]);
      print OUT "\n" ;
      }
    }

  my $too_low=scalar(@delta_glist_miss);
  $h{$id}{'delta Tm'}{'Too low'}=$too_low;
  $h{$id}{'delta Tm'}{'absent or too low'}=$absent+$too_low;
  print OUT "(delta Tm) Too low=$too_low ";
  if ($too_low < 20) { print OUT join(',',@delta_glist_miss) }
  print OUT "\n";
  my $coverage=($number_of_genomes-$absent-$too_low)/$number_of_genomes*100;
  $h{$id}{'delta Tm'}{'coverage'}=$coverage;
  $h{$id}{'delta Tm'}{'covered'}=$number_of_genomes-$absent-$too_low;
  print OUT "(delta Tm) no-alignment ($absent) + too low ($too_low) =",$absent+$too_low," coverage=$coverage%\n";

  for(my $i=0; $i < scalar(@lp_match);$i++)
    {
    if ($lp_match[$i])
      {
      print OUT "(delta probe) mm=$i genomes=$lp_match[$i] ";
      print OUT join(',',@{$lp_glist[$i]}) if(exists $lp_glist[$i]);
      print OUT "\n" ;
      }
   }

  $too_low=scalar(@lp_glist_miss);
  $h{$id}{'delta probe'}{'Too low'}=$too_low;
  $h{$id}{'delta probe'}{'absent or too low'}=$absent+$too_low;
  print OUT "(delta probe) Too low=$too_low ";
  if ($too_low < 10) { print OUT join(',',@lp_glist_miss); }
  print OUT "\n";
  $coverage=($number_of_genomes-$absent-$too_low)/$number_of_genomes*100;
  $h{$id}{'delta probe'}{'covered'}=$number_of_genomes-$absent-$too_low;
  $h{$id}{'delta probe'}{'coverage'}=$coverage;
  print OUT "(delta probe) no-alignment or too low=",$absent+$too_low," coverage=$coverage%\n";
  }

my $number_of_primers=scalar(keys %h);
foreach my $type ('delta Tm','delta probe')
  {
  foreach my $g (sort keys %genomes_status)
    {
    if (not exists $genomes_status{$g}{$pcr}{$primer}{$type} )
      {
      print NOT "($type) $g not covered by any primer\n";
      }
    }
  }

foreach my $type ('delta Tm','delta probe')
  {
  foreach my $g (sort keys %genomes_status)
    {
    if (exists $genomes_status{$g}{$pcr}{$primer}{$type} )
      {
      if (scalar(@{$genomes_status{$g}{$pcr}{$primer}{$type}}) < $number_of_primers)
        {
        my $cov=scalar(@{$genomes_status{$g}{$pcr}{$primer}{$type}})/$number_of_primers*100;
        $genomes_status{$g}{$pcr}{$primer}{"$type cov"}=$cov;
        print NOT "($type) $g $cov% primer coverage ",join(',', @{$genomes_status{$g}{$pcr}{$primer}{$type}}),"\n";
        }
      else
        {
        $genomes_status{$g}{$pcr}{$primer}{"$type cov"}=100;
        }
      }
    }
  }


print SUM "primer set=$primer, genome set=$genome\n";
print SUM "Highest probe Tm $highest_can_tm_id Tm=$highest_can_tm\n";
print SUM "Lowest probe Tm $lowest_can_tm_id Tm=$lowest_can_tm\n";

print SUM "Genomes tested=$number_of_genomes\n";
print SUM "ID Tm Coverage1(abs) Coverage2(abs) Coverage3(abs)\n";
foreach my $id (sort keys %h)
  {
  print SUM "$id $h{$id}{'can'}{'tm'} $h{$id}{'delta Tm'}{'coverage'} ($h{$id}{'delta Tm'}{'covered'}) $h{$id}{'delta probe'}{'coverage'} ($h{$id}{'delta probe'}{'covered'}) $h{$id}{'delta match'}{'coverage'} ($h{$id}{'delta match'}{'covered'}) ";
  print SUM join(',',@{$align_mm{$id}}) if (exists $align_mm{$id});
  print SUM "\n";
  }

print SUM "primers not covered in this analysis=",join(',',sort keys %ignored_ids),"\n";

nstore \%genomes_status, $genome_table_hash_file;
